<!DOCTYPE html>
<html>
  <head>
    <title>Ora: a time library</title>
    <meta charset="utf-8">
    <style>
@import url('https://fonts.googleapis.com/css?family=Inconsolata:400,700|Noto+Sans:400,400i,700');
@import url('https://fonts.googleapis.com/css?family=Arimo:400,400i,700&display=swap');

body { 
    font-family: Arimo, sans-serif; 
}
h1, h2, h3 {
  font-family: inherit;
  font-weight: 700;
}
.remark-slide-content {
  font-size: 24px;
}
.remark-code, .remark-inline-code { font-family: 'Inconsolata'; }

div.footer {
    position: absolute;
    bottom: 0px;
    left: 24px;
    height: 32px;
    width: 100%;
    font-size: 16px;
}

div.footer span {
    font-size: 10pt;
    position: absolute;
    left: 15px;
    bottom: 2px;
}

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Ora

a time library

<img src="calendar-clock.jpg" width="200px">

[`github.com/alexhsamuel/ora`](https://github.com/alexhsamuel/ora)

[`ora.readthedocs.io`](http://ora.readthedocs.io)

---

# Time in Python

Some of the most widely-used libraries:

- `datetime`
- `udatetime`
- `dateutil`
- `pytz`
- `np.datetime64`
- `pd.Timestamp`
- Delorean
- Arrow
- Pendulum
- Babel
- humanize

---

# Tradeoffs

- standard `datetime`
  - no time zones (use `dateutil`)
  - confusing API
  - reasonably fast
  - not vectorized
- NumPy `datetime64`
  - very limited operations; no localization
  - fast, vectorized
- Pandas `Timestamp`
  - full feature set
  - fast, vectorized
  - not a scalar type
- Pendulum _etc._
  - rich feature set
  - slow
  - not vectorized

---

class: center, middle

Which should I use?

---

# Ora

Attempt to build a time library that is:

1. feature-complete

2. fast

3. array-friendly / vectorized

Also a testbed for some ideas and experiments.

---

# API design philosophy

- Central concept is physical <u>time</u>

- Separate concepts for <u>date</u> and <u>daytime</u> (time of day)

- <u>Localization</u>: time ⟷ (date, daytime) mediated by <u>time zone</u>

---

# Example

```py
>>> t = now()
>>> t
ora.Time(2020, 1, 21, 19, 3, 2.58399501, UTC)
>>> print(t)
2020-01-21T19:03:02.58399501+00:00
```

<b>A `Time` doesn't have a time zone.</b>

It's printed with date, daytime, UTC _because we don't have another way_.

Note `float` seconds; more on precision later.

---

# Offset

Beneath the hood, `Time` is an integer offset.

```py
>>> t.offset
2137928358525862245
```

From what?  The epoch.
```py
>>> Time.EPOCH
ora.Time(1, 1, 1, 0, 0, 0.00000000, UTC)
>>> Time.from_offset(0)
ora.Time(1, 1, 1, 0, 0, 0.00000000, UTC)
```

Offset tick size:
```py
>>> Time.DENOMINATOR  # ticks/sec
33554432
>>> Time.RESOLUTION   # secs/tick
2.9802322387695312e-08
```

---

# Localization

A time zone mediates time ⟷ date, daytime<br>
in the function `to_local()`.

```py
>>> d, y = to_local(t, "America/New_York")
>>> d
Date(2020, Jan, 21)
>>> y
Daytime(14, 3, 02.583995014429092)
```

`from_local()` is the inverse operation.

```py
>>> d = Date(2020, 1, 29)
>>> y = Daytime(11, 0, 0)
>>> from_local((d, y), "America/New_York")
ora.Time(2020, 1, 29, 16, 0, 0.00000000, UTC)
```

---

# Dates and daytimes

- Date offset is days since epoch
- Daytime offset is ticks since midnight

```py
>>> Date.EPOCH
Date(1, Jan, 1)
>>> Date(2020, 1, 29).offset
737452
```

```py
>>> Daytime(12, 0, 0).offset
6079859496950169600
>>> Daytime.RESOLUTION
7.105427357601002e-15
```

Sugar:
```py
>>> 2020/Jan/29
Date(2020, Jan, 29)
```

---

# Time zones

What is a time zone?

- A geographical region with a legislated time-dependent mapping:<br>
  time ⟷ date, daytime

```py
>>> TimeZone("America/New_York")
TimeZone('America/New_York')
>>> UTC
TimeZone('UTC')
```

---

# `@` operator

`@` is sugar for both `from_local()` and `to_local()`.

```py
>>> z = TimeZone("America/New_York")
>>> t = (d, y) @ z   # t = from_local((d, y), z)
>>> t
ora.Time(2020, 1, 29, 16, 0, 0.00000000, UTC)
```

```py
>>> d, y = t @ "Asia/Singapore"   # d, y = to_local(t, "...")
>>> d
Date(2020, Jan, 30)
>>> y
Daytime(0, 0, 00.000000000000000)
```

---

# Components

`Time` is physical and <u>has no date/daytime components</u>.
```py
>>> t.hour
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'ora.Time' object has no attribute 'hour'
```

You must convert to local first.
```py
>>> (t @ "America/New_York").hour
11
>>> (t @ "Europe/London").hour
16
```

---

# Components

Dates and daytimes do have components.
```py
>>> d.weekday
Weekday.Thu
>>> d.ordinal   # day of year
30
>>> d.ymdi
20200130
```

---

# Conversions

Ora accepts:
- various formats anywhere a time, date, daytime is needed
- Python `datetime` types
- time zone names

```py
>>> from_local((20200129, "11:00:00"), "America/New_York")
ora.Time(2020, 1, 29, 16, 0, 0.00000000, UTC)
```

```py
>>> t.std
datetime.datetime(2020, 1, 23, 13, 45, 0, 138361, tzinfo=datetime.timezone.utc)
```

```py
>>> d = datetime.date(2020, 11, 20)
>>> Date(d)
Date(2020, Nov, 20)
```

Note operator `@` requires LHS or RHS to be an Ora type.

---

# Arithmetic

No time delta type.
- Time, daytime arithmetic always in seconds.
- Date arithmetic always in days.

Elapsed time:
```py
>>> t1 - t0
1.3957649767398834
```

Seconds since epoch:
```py
>>> Time.EPOCH + 2020 * 365 * 86400
ora.Time(2019, 8, 30, 0, 0, 0.00000000, UTC)
```

Date shift:
```py
>>> Date(2020, 1, 29) + 7
Date(2020, Feb, 5)
```

---

# Types

Why is `Time.DENOMINATOR` set to 1<<25?

Different time types trade off bit width, range, and resolution.

Ora provides multiple time types.

| Type         | Bits | Frac bits |Resolution |Range (years)|
|:-------------|------:|----------:|------------:|
|`SmallTime`   |  32 | 0|1 s        |1970-2106|
|`Unix32Time`  |  32 | 0|1 s        |1902-2038|
|`Unix64Time`  |  64 | 0|1 s        |0001-9999|
|`Time`        |  64 |25|30 ns      |0001-9999|
|`NsTime`      |  64 |* |1 ns       |1677-2262|
|`HiTime`      |  64 |32|233 fs     |1970-2106|
|`Time128`     | 128 |64|54 zs      |0001-9999|

\* Most types have 2^n denominator, but `NsTime` uses 10^9.

Similarly, multiple date and daytime types.

---

# Missing & invalid

Every time, date, daytime type has distinct "missing" and "invalid" values.
```py
>>> Time.MISSING
ora.Time.MISSING
>>> Time.INVALID
ora.Time.INVALID
```

`MISSING` is propagated where possible but never produced by an operation.

---

# Implementation

- templated C++ library with no dependencies
- non-virtual: `sizeof(ora::Time) == 8`
- includes zoneinfo database (but can use system's)
- integer math
- fast overflow checking using condition bit
- hand-written Python wrappers
- only Python dependency is NumPy

As fast or faster than other libraries.  On my laptop:

```py
>>> %timeit now()                                                                                                  
153 ns ± 4.27 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
```

```py
>>> %timeit t @ z                                                                                                  
164 ns ± 12.6 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
```


---

# NumPy

- a dtype for every time, date, daytime type

```py
>>> Time.dtype
dtype(Time)
```

- ufuncs, including localization

```py
>>> import ora.np
>>> dir(ora.np)
['HMS_DTYPE', 'ORDINAL_DATE_DTYPE', 'WEEK_DATE_DTYPE', 'YMD_DTYPE', ...
 'date_from_offset', 'date_from_ordinal_date', 'date_from_week_date', 
 'date_from_ymd', 'date_from_ymdi', 'daytime_from_hms', 'daytime_from_offset',
 'daytime_from_ssm', 'from_local', 'get_day', 'get_hms', 'get_hour',
 'get_minute', 'get_month', 'get_ordinal_date', 'get_second', 'get_ssm', 
 'get_week_date', 'get_weekday', 'get_year', 'get_ymd', 'get_ymdi', 'is_valid',
 'time_from_offset', 'to_local', 'to_offset']
```

---

# NumPy demo

```py
>>> t = now()
>>> a = t + np.arange(0, 300, 60)
>>> a
array([ora.Time(2020, 1, 21, 19, 50, 54.49559500, UTC),
       ora.Time(2020, 1, 21, 19, 51, 54.49559500, UTC),
       ora.Time(2020, 1, 21, 19, 52, 54.49559500, UTC),
       ora.Time(2020, 1, 21, 19, 53, 54.49559500, UTC),
       ora.Time(2020, 1, 21, 19, 54, 54.49559500, UTC)], dtype=Time)
>>> a.itemsize
8
```

Ora's tick representation is simliar to NumPy's; you can `view`.
```py
>>> a = np.array([0, "now"], dtype="datetime64[ns]")
>>> a
array(['1970-01-01T00:00:00.000000000', '2020-01-23T14:00:29.000000000'],
      dtype='datetime64[ns]')
>>> a.view(NsTime)
array([ora.NsTime(1970, 1, 1, 0, 0, 0.000000000, UTC),
       ora.NsTime(2020, 1, 23, 14, 0, 29.000000000, UTC)], dtype=NsTime)
```

---

# NumPy localization

Vectorized `to_local()`, `from_local()` ufuncs.

```py
>>> da, ya = ora.np.to_local(a, "America/New_York")
>>> da
array([Date(2020, Jan, 21), Date(2020, Jan, 21), Date(2020, Jan, 21),
       Date(2020, Jan, 21), Date(2020, Jan, 21)], dtype=Date)
>>> ya
array([Daytime(14, 50, 54.495595008134840),
       Daytime(14, 51, 54.495595008134840),
       Daytime(14, 52, 54.495595008134840),
       Daytime(14, 53, 54.495595008134840),
       Daytime(14, 54, 54.495595008134840)], dtype=Daytime)
```

---

# NumPy components

Access components with ufuncs.

```py
>>> ora.np.get_year(da)
array([2020, 2020, 2020, 2020, 2020], dtype=int16)
```

```py
>>> ora.np.get_ymd(da)
array([(2020, 1, 21), (2020, 1, 21), (2020, 1, 21), (2020, 1, 21),
       (2020, 1, 21)],
      dtype=[('year', '<i2'), ('month', 'u1'), ('day', 'u1')])
```

---

# Formatting

Similar to `datetime` formatting, with many extensions.

`"%i"` is ISO 8601 format (which is default):
```py
>>> format(t, "%i")
'2020-01-21T19:58:17+00:00'
```

```py
>>> format(t, "%.3i")   # precision
'2020-01-21T19:58:17.648+00:00'
```

You can specify time zone in the format spec with `@`.
```py
>>> format(t, "%.3i@America/New_York")
'2020-01-21T14:58:17.648-05:00'
```

```py
>>> z = "Asia/Tokyo"
>>> print(f"it's now {now():@{z}} in {z}")
it's now 2020-01-23T23:21:46+09:00 in Asia/Tokyo
```

---

# Parsing

```py
>>> parse_time("%~D:%~C", "20200129:110000", "America/New_York")                                              
ora.Time(2020, 1, 29, 16, 0, 0.00000000, UTC)
```

Formatting and parsing are fast too.
```py
>>> %timeit format(t, "%.3i")                                                                                      
624 ns ± 10.6 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
```

```py
>>> %timeit parse_time("%i", "2020-01-21T19:58:17.648+00:00")                                                      
241 ns ± 5.02 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
```

---

# Other features

- global system and display time zones

- month and weekday enums

- ISO week dates and ordinal dates

- basic calendar support

---

class: center, middle

# Ora

a time library

<img src="calendar-clock.jpg" width="200px">

[`github.com/alexhsamuel/ora`](https://github.com/alexhsamuel/ora)

[`ora.readthedocs.io`](http://ora.readthedocs.io)

---

    </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({ratio: '3:2'});
    </script>
  </body>
</html>
