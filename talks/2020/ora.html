<!DOCTYPE html>
<html>
  <head>
    <title>Ora: a time library</title>
    <meta charset="utf-8">
    <style>
      /*
      @import url('https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,700|Roboto:400,400i,700');-->
      */
      @import url('https://fonts.googleapis.com/css?family=Inconsolata:400,700|Noto+Sans:400,400i,700');

      body { 
          font-family: 'Noto Sans'; 
      }
      h1, h2, h3 {
        font-family: 'Noto Sans';
        font-weight: 700;
      }
      .remark-slide-content {
        font-size: 36px;
      }
      .remark-code, .remark-inline-code { font-family: 'Inconsolata'; }



div.footer {
    position: absolute;
    bottom: 0px;
    left: 24px;
    height: 32px;
    width: 100%;
    font-size: 16px;
}

div.footer span {
    font-size: 10pt;
    position: absolute;
    left: 15px;
    bottom: 2px;
}

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Ora

a time library

<img src="http://www.muji.eu/images/products/l/4549337330030_l.jpg" width="200px">

[`github.com/alexhsamuel/ora`](https://github.com/alexhsamuel/ora)

[`ora.readthedocs.io`](http://ora.readthedocs.io)

---

class: center

# Time in Python

- `datetime`
- udatetime
- dateutil
- pytz
- `np.datetime64`
- `pd.Timestamp`
- Delorean
- Arrow
- Pendulum
- Babel
- humanize

---

# Tradeoffs

- `datetime` is standard
  - no time zones (use `dateutil`)
  - confusing API
  - no vectorization
  - reasonably fast

- `datetime64` is standard in NumPy
  - _very_ limited operations

- Pendulum _etc_
  - rich feature set
  - easy API
  - no vectorization
  - slow

---

# Ora

Attempt to build a time library that is
1. feature-complete
2. fast
3. array-friendly / vectorizaed

---

# Design philosophy

- Physical time is the main concept
- Date and daytime (time of day) are separate
- Time zones mediate time ⟷ (date, daytime)

---

```py
>>> t = now()
>>> t
ora.Time(2020, 1, 21, 19, 3, 2.58399501, UTC)
>>> print(t)
2020-01-21T19:03:02.58399501+00:00
```

A `Time` is printed in UTC but doesn't carry a timezone.

---

# Offset

Beneath the hood, `Time` is an integer offset.

```py
>>> t.offset
2137928358525862245
```

From what?  The epoch.
```py
>>> Time.EPOCH
ora.Time(1, 1, 1, 0, 0, 0.00000000, UTC)
>>> Time.from_offset(0)
ora.Time(1, 1, 1, 0, 0, 0.00000000, UTC)
```

Offset tick size:
```py
>>> Time.DENOMINATOR  # ticks/sec
33554432
>>> Time.RESOLUTION   # secs/tick
2.9802322387695312e-08
```

---

# Localization

A time zone mediates

    time ⟷ date, daytime

```py
>>> d, y = to_local(t, "America/New_York")
>>> d
Date(2020, Jan, 21)
>>> y
Daytime(14, 3, 02.583995014429092)
```

---

`from_local()` is the inverse operation.

```py
>>> d = Date(2020, 1, 29)
>>> y = Daytime(11, 0, 0)
>>> from_local((d, y), "America/New_York")
ora.Time(2020, 1, 29, 16, 0, 0.00000000, UTC)
```

---

# Time zone objects

```py
>>> TimeZone("America/New_York")
TimeZone('America/New_York')
>>> UTC
TimeZone('UTC')
```

---

# `@` operator

`@` is sugar for both `from_local()` and `to_local()`.

```py
>>> z = TimeZone("America/New_York")
>>> t = (d, y) @ z   # t = from_local((d, y), z)
>>> t
ora.Time(2020, 1, 29, 16, 0, 0.00000000, UTC)
```

```py
>>> d, y = t @ "Asia/Singapore"   # d, y = to_local(t, "...")
>>> d
Date(2020, Jan, 30)
>>> y
Daytime(0, 0, 00.000000000000000)
```

---

# Components

A physical `Time` _has no components_.
```py
>>> t.hour
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'ora.Time' object has no attribute 'hour'
```

You must convert to local first.
```py
>>> (t @ "America/New_York").hour
11
>>> (t @ "Europe/London").hour
16
```

---

# Components

Dates and daytimes do have components.
```py
>>> d.weekday
Weekday.Thu
>>> d.ordinal   # day of year
30
>>> d.ymdi
20200130
```

---

# Arithmetic

No time delta type.
- Time, daytime arithmetic always in seconds.
- Date arithmetic always in days.

```py
>>> t0 = now()
>>> t1 = now()
>>> t1 - t0
1.3957649767398834
```

```py
>>> Date(2020, 1, 29) + 7
Date(2020, Feb, 5)
```

---

# Types

Why is `Time.DENOMINATOR` 1<<25?

Tradeoff among bit width, range, and resolution.

Ora provides multiple time types.

| Type         |Size    |Resolution |Range (years)|
|:-------------|-------:|----------:|------------:|
|`SmallTime`   | 32 bits|1 s        |1970-2106|
|`Unix32Time`  | 32 bits|1 s        |1902-2038|
|`Unix64Time`  | 64 bits|1 s        |0001-9999|
|`Time`        | 64 bits|30 ns      |0001-9999|
|`NsTime`      | 64 bits|1 ns       |1677-2262|
|`HiTime`      | 64 bits|233 fs     |1970-2106|
|`Time128`     |128 bits|54 zs      |0001-9999|

Similarly, multiple date and daytime types.

---

# Missing/invalid

Every time, date, daytime type has distinct "missing" and "invalid" values.
```py
>>> Time.MISSING
ora.Time.MISSING
>>> Time.INVALID
ora.Time.INVALID
```

---

# Implementation

- template C++ library
- hand-written Python wrappers
- integer math with overflow checking by condition bit
- zero dependencies (incl zoneinfo)
- as fast or faster than others

```py
>>> %timeit now()
146 ns ± 1.21 ns per loop
```

---

# NumPy

- a dtype for every time, date, daytime type
- ufuncs, including localization

```py
>>> Time.dtype
dtype(Time)
>>> import ora.np
```

---

# NumPy demo

```py
>>> t = now()
>>> a = t + np.arange(0, 300, 60)
>>> a
array([ora.Time(2020, 1, 21, 19, 50, 54.49559500, UTC),
       ora.Time(2020, 1, 21, 19, 51, 54.49559500, UTC),
       ora.Time(2020, 1, 21, 19, 52, 54.49559500, UTC),
       ora.Time(2020, 1, 21, 19, 53, 54.49559500, UTC),
       ora.Time(2020, 1, 21, 19, 54, 54.49559500, UTC)], dtype=Time)
>>> a.itemsize
8
```

---

# NumPy localization

```py
>>> da, ya = ora.np.to_local(a, "America/New_York")
>>> da
array([Date(2020, Jan, 21), Date(2020, Jan, 21), Date(2020, Jan, 21),
       Date(2020, Jan, 21), Date(2020, Jan, 21)], dtype=Date)
>>> ya
array([Daytime(14, 50, 54.495595008134840),
       Daytime(14, 51, 54.495595008134840),
       Daytime(14, 52, 54.495595008134840),
       Daytime(14, 53, 54.495595008134840),
       Daytime(14, 54, 54.495595008134840)], dtype=Daytime)
```

---

# NumPy components

```py
>>> ora.np.get_year(da)
array([2020, 2020, 2020, 2020, 2020], dtype=int16)
>>> ora.np.get_ymd(da)
array([(2020, 1, 21), (2020, 1, 21), (2020, 1, 21), (2020, 1, 21),
       (2020, 1, 21)],
      dtype=[('year', '<i2'), ('month', 'u1'), ('day', 'u1')])
```

---

# Formatting

Similar to `datetime` formatting, with extensions.

"%i" is ISO format.
```py
>>> format(t, "%i")
'2020-01-21T19:58:17+00:00'
```

Supports precision.
```py
>>> format(t, "%.3i")
'2020-01-21T19:58:17.648+00:00'
```

Specify time zone in format.
```py
>>> format(t, "%.3i@America/New_York")
'2020-01-21T14:58:17.648-05:00'
```

Parsing similar.

---

Other features:

- packaged with zoneinfo library
- global system and display time zones
- month and weekday enums
- ISO week dates and ordinal dates
- basic calendar support

---

class: center, middle
layout: false

# Ora

a time library

[`github.com/alexhsamuel/ora`](https://github.com/alexhsamuel/ora)

[`ora.readthedocs.io`](http://ora.readthedocs.io)

---

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
